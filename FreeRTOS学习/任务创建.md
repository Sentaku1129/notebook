# 任务创建

## 任务概念

### 什么是任务

> 任务函数没有返回值，并且参数是指针类型(很少使用,基本可以不管)

````C
void entry_task(void *pvParameters)
{
    /* 任务主体，无限循环且不能返回值 */
    while(1)
    {
        /* 任务主题代码 */
    }
}
````

## 任务的实现过程

### 定义任务栈

> 下面的任务分别定义的任务栈大小为:128和64,展通空间大小为128*4字节和64*4字节

````C
//任务堆栈大小
#define TASK1_STK_SIZE 128
StackType_t Task1Stack[TASK1_STK_SIZE];

//任务堆栈大小
#define TASK2_STK_SIZE 64
StackType_t Task2Stack[TASK2_STK_SIZE];
````

### 定义任务函数

````C
//任务1函数
void tsak1_task(void *pvParameters)
{
    while(1)
    {
        LED1 = 0;
        vTaskDelay(500);
        LED1 = 1;
        vTaskDelay(500);
    }
}

//任务2函数
void tsak2_task(void *pvParameters)
{
    while(1)
    {
        LED2 = 0;
        vTaskDelay(1000);
        LED2 = 1;
        vTaskDelay(1000);
    }
}
````

> vTaskDelay()为FreeRTOS提供的延时函数,在FreeRTOSConfig.h文件中进行了时钟节拍的配置,如下

````C
//RTOS系统节拍中断的频率。即一秒中断的次数，每次中断RTOS都会进行任务调度
#define configTICK_RATE_HZ      (( TickType_t )1000)
````

### 任务控制块

> 人物的参数可以通过任务控制块指定

````C
typedef struct tskTaskControlBlock             
{
    // 这里栈顶指针必须位于TCB第一项是为了便于上下文切换操作，详见xPortPendSVHandler中任务切换的操作。
    volatile StackType_t    *pxTopOfStack;   /* 栈顶指针 */ 
    // MPU相关暂时不讨论
    #if ( portUSING_MPU_WRAPPERS == 1 )
        xMPU_SETTINGS    xMPUSettings;        
    #endif
    // 表示任务状态，不同的状态会挂接在不同的状态链表下
    ListItem_t            xStateListItem;    /* 任务节点 */
    // 事件链表项，会挂接到不同事件链表下
    ListItem_t            xEventListItem;        
    // 任务优先级，数值越大优先级越高
    UBaseType_t            uxPriority;            
    // 指向堆栈起始位置，这只是单纯的一个分配空间的地址，可以用来检测堆栈是否溢出
    StackType_t            *pxStack;         /* 任务栈气质地址 */  
    // 任务名称，字符串形式
    char                pcTaskName[ configMAX_TASK_NAME_LEN ];
    // 指向栈尾，可以用来检测堆栈是否溢出
    #if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
        StackType_t        *pxEndOfStack;        
    #endif
    // 记录临界段的嵌套层数
    #if ( portCRITICAL_NESTING_IN_TCB == 1 )
        UBaseType_t        uxCriticalNesting;    
    #endif
    // 跟踪调试用的变量
    #if ( configUSE_TRACE_FACILITY == 1 )
        UBaseType_t        uxTCBNumber;        
        UBaseType_t        uxTaskNumber;        
    #endif
    // 任务优先级被临时提高时，保存任务原本的优先级
    #if ( configUSE_MUTEXES == 1 )
        UBaseType_t        uxBasePriority;        
        UBaseType_t        uxMutexesHeld;
    #endif
    // 任务的一个标签值，可以由用户自定义它的意义，例如可以传入一个函数指针可以用来做Hook    函数调用
    #if ( configUSE_APPLICATION_TASK_TAG == 1 )
        TaskHookFunction_t pxTaskTag;
    #endif
    // 任务的线程本地存储指针，可以理解为这个任务私有的存储空间
    #if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
        void            *pvThreadLocalStoragePointers[     configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
    #endif
    // 运行时间变量
    #if( configGENERATE_RUN_TIME_STATS == 1 )
        uint32_t        ulRunTimeCounter;    
    #endif
    // 支持NEWLIB的一个变量
    #if ( configUSE_NEWLIB_REENTRANT == 1 )
        struct    _reent xNewLib_reent;
    #endif
    // 任务通知功能需要用到的变量
    #if( configUSE_TASK_NOTIFICATIONS == 1 )
        // 任务通知的值 
        volatile uint32_t ulNotifiedValue;
        // 任务通知的状态
        volatile uint8_t ucNotifyState;
    #endif
    // 用来标记这个任务的栈是不是静态分配的
    #if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) 
        uint8_t    ucStaticallyAllocated;         
    #endif
    // 延时是否被打断
    #if( INCLUDE_xTaskAbortDelay == 1 )
        uint8_t ucDelayAborted;
    #endif
    // 错误标识
    #if( configUSE_POSIX_ERRNO == 1 )
        int iTaskErrno;
    #endif
} tskTCB;
typedef tskTCB TCB_t; 
````

### 列表和列表项

1. 列表

> listFIRST_LIST_INTEGRITY_CHECK_VALUE和istSECOND_LIST_INTEGRITY_CHECK_VALUE用来检查列表的完整性,默认不开启;如果要开启需要将配置文件中的宏设置为1,开启之后分别会添加一个整型变量值1和2,初始化时会写入一个特殊的值

````C
typedef struct xLIST
{
    listFIRST_LIST_INTEGRITY_CHECK_VALUE 
    /* 列表内有效列表项个数 */
    configLIST_VOLATILE UBaseType_t uxNumberOfItems;
    /* 记录当前列表项索引号，用于遍历列表 */
    ListItem_t * configLIST_VOLATILE pxIndex;           
    /* 列表中最后一个列表项，表示列表结束 */
    MiniListItem_t xListEnd;
    listSECOND_LIST_INTEGRITY_CHECK_VALUE
} List_t;
````

2. 列表项

> 类似于列表中的两个参数,需要在配置文件中使能才能开启对应的功能——检查列表项完整性

````C
struct xLIST_ITEM
{
    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE
    /* 列表项值 */
    configLIST_VOLATILE TickType_t xItemValue;          
    /* 指向下一个列表项值 */
    struct xLIST_ITEM * configLIST_VOLATILE pxNext;     
    /* 指向上一个列表项值 */
    struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
    /* 当前列表项的拥有者 */
    void * pvOwner;                                     
    /* 当前列表项归属的列表,指向就绪列表 */
    void * configLIST_VOLATILE pvContainer; 
    listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE            
};
typedef struct xLIST_ITEM ListItem_t;
````

3. 迷你列表项

````C
struct xMINI_LIST_ITEM
{
     listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE  
    /* 列表项值 */
    configLIST_VOLATILE TickType_t xItemValue;
    /* 指向下一个列表项值 */
    struct xLIST_ITEM * configLIST_VOLATILE pxNext;
    /* 指向上一个列表项值 */
    struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
    struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
};
typedef struct xMINI_LIST_ITEM MiniListItem_t;
````
